/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import javax.swing.*;
import java.util.List;
import java.util.ArrayList;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
import javafx.scene.text.*;
import javafx.scene.control.Label;
import javafx.animation.*;
import java.time.*;
import javafx.scene.*;
import javafx.scene.paint.*;
import javafx.scene.layout.VBox;
import javafx.geometry.Pos; 
import java.math.BigDecimal;
import java.math.MathContext;


public class App extends Application{
	private double opacity = 1;
	// private Label label;
	// private Label label2;
	private Text text;
	private Text text2;
	private String lyrics = "";
	private Stop[] stops;
	private LinearGradient lg;
	private Song s;
	
    @Override
    public void start(Stage primaryStage) {
		
        primaryStage.setTitle("Karaoke!");
        
		// label = new Label("huh");
		// label2 = new Label("what");
		
		text = new Text();
		text2 = new Text();
		text.setFont(new Font("Arial", 50));
		text2.setFont(new Font("Arial", 50));


		VBox root = new VBox(50, text, text2);
		root.setAlignment(Pos.CENTER);

		// label.setId("custom-label");
		// label2.setId("custom-label2");
		
		// root.getChildren().add(label);
		// root.getChildren().add(label2);
		
		




		Scene scene = new Scene(root, 1200, 500);
		scene.getStylesheets().add("file:style.css");
		
		AnimationTimer timer = new MyTimer();
		timer.start();
		
        primaryStage.setScene(scene);
        primaryStage.show();
		
		s = KaraokePlayer.haiYorokonde();
        //s.printSong();
		
        KaraokePlayer k = new KaraokePlayer(s);
        k.initilizeSong();   

    }
	
	private class MyTimer extends AnimationTimer{
		double fillPerc = 0;
		int frames = 0;
		String s1;
		String s2;
		String s3;
		String s4;
		int currMeasure = 0;
		BigDecimal measureLength;
		BigDecimal beatDuration;
		BigDecimal currTime;
		BigDecimal currSongTime;
		int fourthM = 0;
		long prev;
		long time;
		boolean end = false;
		double currMP = 0;
		
		
		@Override
		public void handle(long now) {
			if(prev == 0){
				prev = now;			
				time = 0;
			}
			else{
				time += now - prev;
				prev = now;
			}
			
			
			//s.bpm
			// BPM = 1 minute / beat duration
			// 120BPM = 1 m / 0.5 s
			// beat duration = 1 minute / BPM 
			//  = 1 / 147
			
			if( currMeasure < s.set.size()){
				
				beatDuration = BigDecimal.valueOf(60.0 / s.bpm); // seconds
				int n = s.getMeasureAt(currMeasure).numBeats;
				measureLength = beatDuration.multiply(new BigDecimal(n)); // measure length in seconds.
				// currMeasure starts at 0.
				// inrement by 1 once frames reaches measureLength. 
				// need to convert frames to seconds
				// seconds = frames / 60 (FPS)
				// (frames/60) % measureLength == 0 // everytime it's 0, measureLength has been reached
				// so increment the currMeasure
				
				/*
					want to have 1 measure of lyrics per line 
					4 lines
					currMeasure;
					cM + 1
					cM + 2
					cM + 3
				
					want 2 lines stay while next 2 play
					
					currMeasure % 2. 
					
					OOB Case
					4 Measures left:
					cM 
					cM + 1
					cM + 2
					cM + 3
					
						
						
					
					3 Measures Left (Just the case before, but without one measure):
					cM
					cM + 1
					cM + 2
					
					...
					
					1 Measure Left
					cM
					
					0 M Left
					Nothing
					
					
					Ex:
					currMeasure = 1
						cM 
						cM2
						cM3
						cM4
					
					currMeasure = 2
						cM
						cM2
						cM3
						cM4
						
					currMeasure = 3
						cM5
						cM6
						cM3
						cM4
					
					currMeasure = 4
						cM5
						cM6
						cM3
						cM4
					
					currMeasure = 5
						cM5
						cM6
						cM7
						cM8
						
					Only change text of texts every 2 measures	
					
					
				*/ 
				
				
				// else if (currMeasure + 2 < s.set.size()){
					// text.setText("\n" + (s.set).get(currMeasure).printMeasureLyrics());
					// text2.setText((s.set).get(currMeasure + 1).printMeasureLyrics() + "\n" + (s.set).get(currMeasure + 2).printMeasureLyrics());
				// }					
				// else if (currMeasure + 1 < s.set.size()){
					// text.setText("");
					// text2.setText((s.set).get(currMeasure).printMeasureLyrics() + "\n" + (s.set).get(currMeasure + 1).printMeasureLyrics());
				// }
				// else if (currMeasure < s.set.size()){
					// text.setText("");
					// text2.setText((s.set).get(currMeasure).printMeasureLyrics());
				// }
				// else{						
					// text.setText("");
					// text2.setText("");
					// System.out.println("End of Song");
				// }
				
				
				currTime = BigDecimal.valueOf( time/1000000000.0 );
				currSongTime = measureLength.multiply(new BigDecimal(currMeasure));

				if (  (currTime.compareTo(currSongTime) > 0) ){
					
					
					
					if(currMeasure + 3 < s.set.size()){
						if(currMeasure % 4 == 0){
							text.setText((s.set).get(currMeasure).printMeasureLyrics() + (s.set).get(currMeasure + 1).printMeasureLyrics());
							text2.setText((s.set).get(currMeasure + 2).printMeasureLyrics()  + (s.set).get(currMeasure + 3).printMeasureLyrics());
							System.out.println("change 1");
							
							// Need to change text for 3rd and 4th measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text2.setFill(lg);
							
						}
						else if (currMeasure % 4 == 2){
							text2.setText((s.set).get(currMeasure).printMeasureLyrics()  + (s.set).get(currMeasure + 1).printMeasureLyrics());	
							text.setText((s.set).get(currMeasure + 2).printMeasureLyrics()  + (s.set).get(currMeasure + 3).printMeasureLyrics());
							System.out.println("change 2");
							
							// Need to change text for 1st and 2nd measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text.setFill(lg);
						}
					}
					else if(currMeasure + 2 < s.set.size()){ // same as before, just without 4th measure
						if(currMeasure % 4 == 0){
							text.setText((s.set).get(currMeasure).printMeasureLyrics() + (s.set).get(currMeasure + 1).printMeasureLyrics());
							text2.setText((s.set).get(currMeasure + 2).printMeasureLyrics());
							System.out.println("change 1");
							
							// Need to change text for 3rd and 4th measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text2.setFill(lg);
							
						}
						else if (currMeasure % 4 == 2){
							text2.setText((s.set).get(currMeasure).printMeasureLyrics()  + (s.set).get(currMeasure + 1).printMeasureLyrics());	
							text.setText((s.set).get(currMeasure + 2).printMeasureLyrics());
							System.out.println("change 2");
							
							// Need to change text for 1st and 2nd measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text.setFill(lg);
						}
					}
					else if(currMeasure + 1 < s.set.size()){ // same as before, just without 3rd, 4th measure
						if(currMeasure % 4 == 0){
							text.setText((s.set).get(currMeasure).printMeasureLyrics() + (s.set).get(currMeasure + 1).printMeasureLyrics());
							text2.setText("");
							System.out.println("change 1");
							
							// Need to change text for 3rd and 4th measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text2.setFill(lg);
							
						}
						else if (currMeasure % 4 == 2){
							text2.setText((s.set).get(currMeasure).printMeasureLyrics()  + (s.set).get(currMeasure + 1).printMeasureLyrics());	
							text.setText("");	
							System.out.println("change 2");
							
							// Need to change text for 1st and 2nd measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text.setFill(lg);
						}
					}
					else if(currMeasure < s.set.size()){ // same as before, just without 2nd, 3rd, 4th measure
						if(currMeasure % 4 == 0){
							text.setText((s.set).get(currMeasure).printMeasureLyrics());
							text2.setText("");
							System.out.println("change 1");
							
							// Need to change text for 3rd and 4th measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text2.setFill(lg);
							
						}
						else if (currMeasure % 4 == 2){
							text2.setText((s.set).get(currMeasure).printMeasureLyrics());	
							text.setText("");	
							System.out.println("change 2");
							
							// Need to change text for 1st and 2nd measures back to gray
							stops = new Stop[] { new Stop(0, Color.RED), new Stop(0 , Color.GRAY)};
							lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
							text.setFill(lg);
						}
					}
					
					currMeasure++;		
					//System.out.println(beatDuration + " : " + measureLength); 
					System.out.println(currMeasure - 1);
				}	
				
				
			}
			else if(currMeasure == s.set.size()){ // need to get last measure
				beatDuration = BigDecimal.valueOf(60.0 / s.bpm); // seconds
				int n = s.getMeasureAt(currMeasure-1).numBeats;
				measureLength = beatDuration.multiply(new BigDecimal(n)); // measure length in seconds.
				
				currTime = BigDecimal.valueOf( time/1000000000.0 );
				currSongTime = measureLength.multiply(new BigDecimal(currMeasure));
			}
						
			// Filling text now (Use currMeasure - 1) for current measure
			
			// Get an approximation of the current point of the measure
			BigDecimal p = currTime.remainder(measureLength);
			//System.out.println(p);
			BigDecimal perc = p.divide(measureLength, new MathContext(3));
			
			//System.out.println(perc);
			fillPerc = perc.doubleValue();
			//System.out.println(fillPerc);
			
			currMP = p.doubleValue();
			
			//System.out.println(p + " : " + perc + " : " + fillPerc );
			
			//Fill for specific parts of the each group of 4 measures
			
			
			
			double percent;
			if( (currMeasure-1) % 4 == 0){
				// Need to get length of 1st measure and one after it (if it exists)				
				
				// 2nd measure exists
				if ( currMeasure < (s.set).size() ) {
					// get total length of both first and second  measures
					int lengthTotal  = s.getMeasureAt(currMeasure-1).printMeasureLyrics().length() + s.getMeasureAt(currMeasure).printMeasureLyrics().length();
					
					// get percentage first measure has between total of 2 measures
					int length1 = s.getMeasureAt(currMeasure-1).printMeasureLyrics().length();
					percent = (double) length1/lengthTotal;
				}
				else{//doesn't exist
					percent = 1; // is 100%
				}
				// percent = sum of values of the notes * length
				double p2 = 0;
				double mP = 0;
				boolean endfill = false;
				for( int i = 0; i < s.getMeasureAt(currMeasure -1).getSet().size(); i++ ){
					int length1 = s.getMeasureAt(currMeasure-1).printMeasureLyrics().length();
					
					// percentage of note of the measure
					Rest n = s.getMeasureAt(currMeasure - 1).getNoteAt(i);
					mP += (n.getLength() * n.getSyllable().length() / length1) ;
					
					if(!endfill){						
						if( currMP < mP)  {
							// Note percentage = mP - currMP
							p2 += mP - currMP;
							endfill = true;
						}
						else{
							p2 += mP;
						}
					}
					
				}
				
				
				
				stops = new Stop[] { new Stop( (p2 * percent), Color.RED), new Stop( (p2 * percent) , Color.GRAY)};
				lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				text.setFill(lg);			
			}
			else if( (currMeasure-1) % 4 == 1){
				// Fill the second measure in the text1
				// Assume that first measure has already been filled
				
				// get total length of "2nd" measure and measure before
				int lengthTotal  = s.getMeasureAt(currMeasure - 1).printMeasureLyrics().length() + s.getMeasureAt(currMeasure - 2).printMeasureLyrics().length();
				
				// get percentage first measure has between total of 2 measures
				int length1 = s.getMeasureAt(currMeasure-2).printMeasureLyrics().length();
				int length2 = s.getMeasureAt(currMeasure-1).printMeasureLyrics().length();
				double percent1 = (double) length1/lengthTotal;
				double percent2 = (double) length2/lengthTotal;
				
				
				stops = new Stop[] { new Stop( ( percent1 + (fillPerc * percent2)), Color.RED), new Stop( ( percent1 + (fillPerc * percent2)) , Color.GRAY)};
				lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				
				text.setFill(lg);
			}
			else if( (currMeasure-1) % 4 == 2){
				//Should be the same case like 1st and 2nd measure
				
				// 4th measure exists
				if ( currMeasure < (s.set).size() ) {
					// get total length of both first and second  measures
					int lengthTotal  = s.getMeasureAt(currMeasure-1).printMeasureLyrics().length() + s.getMeasureAt(currMeasure).printMeasureLyrics().length();
					
					// get percentage first measure has between total of 2 measures
					int length1 = s.getMeasureAt(currMeasure-1).printMeasureLyrics().length();
					percent = (double) length1/lengthTotal;
				}
				else{//doesn't exist
					percent = 1; // is 100%
				}
				
				stops = new Stop[] { new Stop( (fillPerc * percent), Color.RED), new Stop( (fillPerc * percent) , Color.GRAY)};
				lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				text2.setFill(lg);
			}
			else if ( (currMeasure-1) % 4 == 3 ){
				//Should be the same case as before
				
				// Fill the second measure in the text2
				// Assume that first measure has already been filled
				
				// get total length of "2nd" measure and measure before
				int lengthTotal  = s.getMeasureAt(currMeasure - 1).printMeasureLyrics().length() + s.getMeasureAt(currMeasure - 2).printMeasureLyrics().length();
				
				// get percentage first measure has between total of 2 measures
				int length1 = s.getMeasureAt(currMeasure-2).printMeasureLyrics().length();
				int length2 = s.getMeasureAt(currMeasure-1).printMeasureLyrics().length();
				double percent1 = (double) length1/lengthTotal;
				double percent2 = (double) length2/lengthTotal;
				
				stops = new Stop[] { new Stop( ( percent1 + (fillPerc * percent2)), Color.RED), new Stop( ( percent1 + (fillPerc * percent2)) , Color.GRAY)};
				lg = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE, stops);
				text2.setFill(lg);
			}
			
		
			
			
			
			
			
			
			
			
			frames++;
		}
	}
	
	

	
    public static void main(String[] args){
        launch(args);
    }

    public static Song songTest(){
        
        List<Measure> ms = new ArrayList<Measure>();
        Measure m = new Measure(4, 0.25, new ArrayList<Rest>());
        int i = 0;
        while(i < 4){
            m.addNote(new Rest(0.25));
            i++;
        }
        Song s = new Song(120, ms);
        s.addMeasure(m);
        
        return s;
    }

}
